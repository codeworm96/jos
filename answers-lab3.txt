1. What is the purpose of having an individual handler function for each
exception/interrupt? (i.e., if all exceptions/interrupts were delivered
to the same handler, what feature that exists in the current
implementation could not be provided?)

If there is only one handler, knowning which exception/interrupt has
happened can be hard. Also, we will be unable to set different permission
for different handler.

2. Did you have to do anything to make the user/softint program behave
correctly? The grade script expects it to produce a general protection
fault (trap 13), but softint's code says int $14. Why should this
produce interrupt vector 13? What happens if the kernel actually allows
softint's int $14 instruction to invoke the kernel's page fault handler
(which is interrupt vector 14)?

No. Because the DPL of interrupt vector 14 is set to 0, the user program
do not have enough permission to int $14 and a general protection fault is
triggered. Normally, the kernel's page fault handler will assume that the
page fault can only be triggered by hardware. If a user program can invoke
it, this may violate the page fault handler's precondition and may cause
some errors.

3. The break point test case will either generate a break point exception
or a general protection fault depending on how you initialized the break
point entry in the IDT (i.e., your call to SETGATE from trap_init).
Why? How do you need to set it up in order to get the breakpoint exception
to work as specified above and what incorrect setup would cause it to
trigger a general protection fault?

If I set the DPL of breakpoint exception to 0, the user programs are not
allowed to invoke breakpoint exception handler and would trigger a general
protection fault. In order to make the breakpoint exception work, the DPL
should be set to 3. This is because the CPU will compare the current privilege
level with DPL when executing int instruction.

4. What do you think is the point of these mechanisms, particularly in
light of what the user/softint test program does?

These mechanisms allow the provider of the procedure to specify code
with which permission can call it and prevent code without permission
from calling these procedure to cause some damage.
